_HiStOrY_V2_
import\040xtci\012
.\012
├──\040dist/\012
├──\040hellostackoverflow.egg-info/\012
├──\040LICENCE.txt\012
├──\040README.rst\012
├──\040setup.py\012
└──\040hellostackoverflow/\012
\040\040\040\040├──\040__init__.py\012
import xtcsi
import xtci
import sys
print(sys.path)
import sys
print(sys.path)
HIRAM.CTL1990s_v201910_tigercpu_intelmpi_18_540PE.TCI.py
import xtci
import sys
print(sys.path)
"cut_mlp",
"cut_time",
exit
exit()
import sys
exit
import sys
ls
print(sys.path)
exit
ls
exit
squeue
ẽit
exit
def trend_help(option:Optional[Literal['METRICS','METRIC-sing']]):
    if option == 'METRICS':
        for key, value in METRICS.items():
            print(f"{key}: {value['full_name']}")
    elif option == 'METRIC-sing':
        PRINT
    else:
        print("Invalid option")
exit
points: Tuple[Tuple[float,float]
exit
clear
# --------------#!/bin/bash
#SBATCH --job-name=JOBNAME
#SBATCH --output=JOBNAME.out
#SBATCH --error=JOBNAME.err
#SBATCH --partition=PARTITION
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=10
#SBATCH --time=10:00:00
python "$@"
du_
def water_vapour_mass_absolute(
    SH: Union[np.ndarray, xr.DataArray],
    U: Union[np.ndarray, xr.DataArray],
    V: Union[np.ndarray, xr.DataArray],
    sP: Union[np.ndarray, xr.DataArray]
) -> Union[np.ndarray, xr.DataArray]:
    """
    Calculate vertically intergrated water vapour mass in the air.
    Parameters
    ----------
    SH : float
        Specific humidity in percentage.
    P : float
        Atmospheric pressure in Pa.
    Returns
    -------
    float
        Water vapour mass in the air in kg/m^3.
    """
    #? MFC = -u\frac{dq}{dx} - v\frac{dq}{dy} - q\left(\frac{du}{dx} + \frac{dv}{dy}\right)
    g = 9.80665 #m/s^2
    # Vapour mass from each layer
        # Delta pressure between layers
        #? Negative since pressure decreases with height
    P_name = find_name(SH, 'level')
    P = SH[P_name]
    # Calculate pressure gradient based on surface pressure and pressure levels
    dp = gc.meteorology.delta_pressure(P, sP)
    # Layer mass
    layer_mass = dp/g
    # Intergrated vapour mass
    vapour_mass = SH * layer_mass
    if isinstance(SH, xr.DataArray):
        int_vapour_mass = vapour_mass.sum(dim = P_name)
    else:
        int_vapour_mass = np.sum(vapour_mass, axis=0)
    # Intergrated moisture flux
    # Method 1: My function
    du_dx = gradient_ds(U, 'lon')
    dv_dy = gradient_ds(V, 'lat')
    dq_dx = gradient_ds(SH, 'lon')
    dq_dy = gradient_ds(SH, 'lat')
    # Method 2: Geocat.comp
    du_dx, du_dy = gc.gradient(U)
    dv_dx, dv_dy = gc.gradient(V)
    dq_dx, dq_dy = gc.gradient(SH)
    if isinstance(SH, xr.DataArray):
        MFC = - U * dq_dx - V * dq - SH * (gradient_ds(U, 'lon') + gradient_ds(V, 'lat'))
    else:
        MFC = - U * gradient_ds(SH, 0) - V * gradient_ds(SH, 1) - SH * (gradient_ds(U, 0) + gradient_ds(V, 1))
exit
"""
def plot_correlation_maps(variable,metric):
    fig = plt.figure(figsize=(40, 70))
    # Setup figure
    gs_main = gridspec.GridSpec(len(seasons), len(datasets),\
                                    width_ratios=[1,1,1,1.15], height_ratios=[1]*len(seasons))
    gs_main.update(hspace=0.05, wspace=-0.5)
    # Create all subplots first
    axes = []
    for i in range(5):  # 5 rows for seasons
        for j in range(4):  # 4 columns for datasets
            ax = fig.add_subplot(gs_main[i, j], projection=ccrs.PlateCarree())
            axes.append(ax)
    # Color map for correlation values
    if variable == "T2m":
        cmap = sns.color_palette("RdBu", as_cmap=True).reversed()
    else:
        cmap = sns.color_palette("RdBu", as_cmap=True)
    # Process each season and dataset
    for i, season in enumerate(seasons):
        for j, dataset in enumerate(datasets):
            ax = axes[i*4+j]
            # Set transparent background
            ax.set_facecolor('none')
            # Plot island
            if ax == axes[i*4+3]:
                plot_shp(ax,dem=False, island_full = True, axis='on')
            else:
                plot_shp(ax,dem=False, island_only = True, axis='on', extend = [101, 113, 8, 25])
            # Load data
            filename = f"{variable}_{metric}_{season}_merge.csv"
            filepath = os.path.join(Data_csv, 'ensemble', filename)
            try:
                df = pd.read_csv(filepath)
                # Check if dataset column exists
                if dataset in df.columns:
                    # Get lat/lon data
                    # Assuming lat/lon are in the dataframe or need to be merged
                    # If not in df, you'll need to merge with station metadata
                    merged_df = pd.merge(df, station_data[['name_station', 'lat', 'lon']],
                                        on='name_station', how='left')
exit
ax.text(-0.175, 0.5, season.upper(),
        transform=ax.transAxes,
        fontsize=50,
        rotation=90,
        va='center',
        )
gs.update(wspace = -0.345)
